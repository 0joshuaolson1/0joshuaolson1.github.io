<!DOCTYPE html>
<html lang=en>
<head>
	<meta charset=utf-8>
	<meta name=viewport content='width=device-width'>
	<meta name=description content='bring-your-own-randomness random number tool'>
	<meta name=author content=https://github.com/0joshuaolson1/randint>
	<title>Randint</title>
</head>
<!--labels, footer, a11y/semantics/validate, minify/offline...-->
<body>
	<noscript>
		<strong>Error: JavaScript is not available; this webpage cannot do its job with the current browser setup.</strong>
		<hr>
	</noscript>
	Short url: <a href=https://u.nu/randint~>u.nu/randint</a>
	<br>
	<a href=https://www.alpertron.com.ar/ECM.HTM>this calculator may help</a>
	<hr>
	1. <button onclick=openRNG() onkeypress=openRNG()>prepare to get an integer between 1 and</button>
	<input id=I type=text>
	<br><br>
	(2.) <a id=L href=https://qrng.anu.edu.au/>open link in another tab</a> to use https://qrng.anu.edu.au
	<br><br>
	3. <button onclick=tryRandint() onkeypress=tryRandint()>try with hex (skips other chars):</button>
	<input id=N type=text>
	<br><br>
	4! <input id=O type=text>
	<script>
let n
const b=(()=>{
    function BigInteger(a,b,c){if(a != null)this.fromString(a,b)}
    function nbi() { return new BigInteger(null); }
    BigInteger.prototype.am=function(i,x,w,j,c,n){
      var xl = x&0x3fff, xh = x>>14;
      while(--n >= 0) {
        var l = this[i]&0x3fff;
        var h = this[i++]>>14;
        var m = xh*l+h*xl;
        l = xl*l+((m&0x3fff)<<14)+w[j]+c;
        c = (l>>28)+(m>>14)+xh*h;
        w[j++] = l&0xfffffff;
      }
      return c;
    }
    BigInteger.prototype.DM = ((BigInteger.prototype.DV=(1<<28))-1);
    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2,BI_FP);
    BigInteger.prototype.F1 = BI_FP-28;
    BigInteger.prototype.F2 = 2*28-BI_FP;
    var BI_RC = new Array();
    var rr,vv;
    rr = "0".charCodeAt(0);
    for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
    rr = "a".charCodeAt(0);
    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
    rr = "A".charCodeAt(0);
    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
    var intAt=(s,i)=>BI_RC[s.charCodeAt(i)]
    function bnpCopyTo(r) {
      for(var i = this.t-1; i >= 0; --i) r[i] = this[i];
      r.t = this.t;
      r.s = this.s;
    }
    function bnpFromInt(x) {
      this.t = 1;
      this.s = 0;
      if(x > 0) this[0] = x;
      else this.t = 0;
    }
    function nbv(i) { var r = nbi(); r.fromInt(i); return r; }
    function bnpFromString(s,b) {
      if(b<16){this.fromRadix(s,b);return}
      this.t = 0;
      this.s = 0;
      var i = s.length, mi = false, sh = 0;
      while(--i >= 0) {
        var x = intAt(s,i);
        mi = false;
        if(sh == 0)
          this[this.t++] = x;
        else
          this[this.t-1] |= x<<sh;
        sh +=4;
        if(sh >= 28) sh -= this.28;
      }
      this.clamp();
    }
    function bnpClamp() {
      var c = this.s&this.DM;
      while(this.t > 0 && this[this.t-1] == c) --this.t;
    }
    function bnCompareTo(a) {
      var r = this.s-a.s;
      var i = this.t;
      r = i-a.t;
      return this[--i]-a[i];
    }
    function nbits(x) {
      var r = 1, t;
      if((t=x>>8) != 0) { x = t; r += 8; }
      if((t=x>>4) != 0) { x = t; r += 4; }
      if((t=x>>2) != 0) { x = t; r += 2; }
      if((t=x>>1) != 0) { x = t; r += 1; }
      return r;
    }
    function bnBitLength() {
      return 28*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));
    }
    function bnpDLShiftTo(n,r) {
      var i;
      for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];
      for(i = n-1; i >= 0; --i) r[i] = 0;
      r.t = this.t+n;
      r.s = this.s;
    }
    function bnpDRShiftTo(n,r) {
      for(var i = n; i < this.t; ++i) r[i-n] = this[i];
      r.t = Math.max(this.t-n,0);
      r.s = this.s;
    }
    function bnpLShiftTo(n,r) {
      var bs = n%28;
      var cbs =28-bs;
      var bm = (1<<cbs)-1;
      var ds = Math.floor(n/28), c = (this.s<<bs)&this.DM, i;
      for(i = this.t-1; i >= 0; --i) {
        r[i+ds+1] = (this[i]>>cbs)|c;
        c = (this[i]&bm)<<bs;
      }
      r[ds] = c;
      r.t = this.t+ds+1;
      r.s = this.s;
      r.clamp();
    }
    function bnpRShiftTo(n,r) {
      r.s = this.s;
      var ds = Math.floor(n/28);
      if(ds >= this.t) { r.t = 0; return; }
      var bs = n%28;
      var cbs = 28-bs;
      var bm = (1<<bs)-1;
      r[0] = this[ds]>>bs;
      for(var i = ds+1; i < this.t; ++i) {
        r[i-ds-1] |= (this[i]&bm)<<cbs;
        r[i-ds] = this[i]>>bs;
      }
      r[this.t-ds-1] |= (this.s&bm)<<cbs;
      r.t = this.t-ds;
      r.clamp();
    }
    function bnpSubTo(a,r) {
      var i = 0, c = 0, m = Math.min(a.t,this.t);
      while(i < m) {
        c += this[i]-a[i];
        r[i++] = c&this.DM;
        c >>=28;
      }
      if(a.t < this.t) {
        c -= a.s;
        while(i < this.t) {
          c += this[i];
          r[i++] = c&this.DM;
          c >>=28;
        }
        c += this.s;
      }
      else {
        c += this.s;
        c -= a.s;
      }
      r.s = 0;
      r.t = i;
      r.clamp();
    }
    function bnpMultiplyTo(a,r) {
      var x = this, y = a;
      var i = x.t;
      r.t = i+y.t;
      while(--i >= 0) r[i] = 0;
      for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);
      r.s = 0;
      r.clamp();
    }
    function bnpSquareTo(r) {
      var x = this;
      var i = r.t = 2*x.t;
      while(--i >= 0) r[i] = 0;
      for(i = 0; i < x.t-1; ++i) {
        var c = x.am(i,x[i],r,2*i,0,1);
        r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)
      }
      r[r.t-1] += x.am(i,x[i],r,2*i,0,1);
      r.s = 0;
      r.clamp();
    }
    function bnpDivRemTo(m,q,r) {
      var pm = m;
      var pt = this
      var y = nbi(), ts = this.s, ms = m.s;
      var nsh = 28-nbits(pm[pm.t-1]);
      pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r);
      var ys = y.t;
      var y0 = y[ys-1];
      var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);
      var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;
      var i = r.t, j = i-ys, t = (q==null)?nbi():q;
      y.dlShiftTo(j,t);
      if(r.compareTo(t) >= 0) {
        r[r.t++] = 1;
        r.subTo(t,r);
      }
      BigInteger.ONE.dlShiftTo(ys,t);
      t.subTo(y,y);
      while(--j >= 0) {
        var qd = Math.floor(r[--i]*d1+(r[i-1]+e)*d2);
        r[i]+=y.am(0,qd,r,j,0,ys)
      }
      if(q != null) {
        r.drShiftTo(ys,q);
      }
      r.t = ys;
      r.clamp();
      r.rShiftTo(nsh,r);
    }
    function bnMod(a) {
      var r = nbi();
      this.divRemTo(a,null,r);
      return r;
    }
    function bnpExp(e,z) {
      var r = nbi(), r2 = nbi(), g = z.revert(this), i = nbits(e)-1;
      g.copyTo(r);
      while(--i >= 0) {
        z.sqrTo(r,r2);
        if((e&(1<<i)) > 0) z.mulTo(r2,g,r);
        else { var t = r; r = r2; r2 = t; }
      }
      return z.revert(r);
    }
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.exp = bnpExp
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.ONE=nbv(1)
    function bnpChunkSize(r) { return Math.floor(Math.LN2*28/Math.log(r)); }
    function bnpFromRadix(s,b=10) {
      this.fromInt(0)
      var cs = this.chunkSize(b);
      var d = Math.pow(b,cs),mi = false, j = 0, w = 0;
      for(var i = 0; i < s.length; ++i,++j) {
        var x = intAt(s,i);
        w = b*w+x;
      }
      this.dMultiply(Math.pow(b,j));
      this.dAddOffset(w,0);
    }
    function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }
    function bnpDMultiply(n) {
      this[this.t] = this.am(0,n-1,this,0,0,this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset(n,w) {
      while(this.t <= w) this[this.t++] = 0;
      this[w] += n;
    }
    function NullExp(){}
    function nMulTo(x,y,r) { x.multiplyTo(y,r); }
    function nSqrTo(x,r) { x.squareTo(r); }
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    NullExp.prototype.revert=function(x){return x}
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.intValue=function(){return this.t==1?this[0]:0}
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.pow=function(e){return this.exp(e,new NullExp())}
    return BigInteger//minify
})(),$=i=>document.getElementById(i),openRNG=()=>{
	n=new b($('I').value)
	const d=Math.ceil(n.bitLength()/8)+1,l=Math.ceil(d/1024)
	if(l>1024)return alert('sorry: one qrng.anu.edu.au request only summons 1048576 bytes of the desired '+d)
	$('L').href='https://qrng.anu.edu.au/API/jsonI.php?nocache='+Date.now()+'&type=hex16&length='+l+'&size='+Math.ceil(d/l)
},tryRandint=()=>{
	const N=$('N').value.replace(/[^0-9A-Fa-f]/g,''),m=new b(N,16),B=new b('16').pow(N.length),M=B.subtract(B.mod(n))
	if(M.compareTo(m)<1)return alert('sorry: retry with a smaller value or more hex digits')
	$('O').value=m.mod(n).add(b.ONE).toString()
}
	</script>
</body>
</html>
